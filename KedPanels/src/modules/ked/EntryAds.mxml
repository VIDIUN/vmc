<?xml version="1.0" encoding="utf-8"?>
<mx:Module layout="vertical" xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%"
		   implements="com.vidiun.edw.business.IDrilldownPanel" xmlns:controls="com.vidiun.controls.*"
		   hide="hideHandler(event)" xmlns:control="com.vidiun.edw.control.*"
		   label="{resourceManager.getString('drilldown','ads')}" xmlns:text="com.vidiun.controls.text.*">
	<mx:Metadata>
		[Event(name="validationComplete", type="com.vidiun.edw.events.ValidationResultEvent")] 
		[Event(name="panelDataSaved", type="com.vidiun.edw.events.InternalVedEvent")] 
	</mx:Metadata>
	<mx:Script>
		<![CDATA[
			import com.vidiun.edw.business.permissions.PermissionManager;
			import com.vidiun.edw.constants.PanelConsts;
			import com.vidiun.edw.control.events.CuePointEvent;
			import com.vidiun.edw.events.InternalVedEvent;
			import com.vidiun.edw.events.ValidationResultEvent;
			import com.vidiun.edw.model.datapacks.ContextDataPack;
			import com.vidiun.edw.model.datapacks.CuePointsDataPack;
			import com.vidiun.edw.vo.EntryDetailsValidationError;
			import com.vidiun.events.VClipErrorCodes;
			import com.vidiun.events.VClipEventTypes;
			import com.vidiun.events.VdpEventTypes;
			import com.vidiun.vmvc.model.IDataPackRepository;
			import com.vidiun.types.VidiunAdProtocolType;
			import com.vidiun.types.VidiunAdType;
			import com.vidiun.types.VidiunCuePointType;
			import com.vidiun.types.VidiunEntryStatus;
			import com.vidiun.types.VidiunMediaType;
			import com.vidiun.utils.ObjectUtil;
			import com.vidiun.vo.VidiunAdCuePoint;
			import com.vidiun.vo.VidiunBaseEntry;
			import com.vidiun.vo.VidiunMediaEntry;
			
			import flash.utils.setTimeout;
			
			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.SWFLoader;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.resources.ResourceManager;
			
			
			private static const BULK_ACTIONS:Array = [{label: ResourceManager.getInstance().getString('drilldown', 'ads_bulk_upload'), value: 'ads_bulk_upload'},
				{label: ResourceManager.getInstance().getString('drilldown', 'ads_bulk_download'), value: 'ads_bulk_download'},
				{label: ResourceManager.getInstance().getString('drilldown', 'ads_bulk_sample'), value: 'ads_bulk_sample'}];
			
			private static const AD_TYPES:Array = [{label: ResourceManager.getInstance().getString('drilldown', 'type_midroll'), value: VidiunAdType.VIDEO},
				{label: ResourceManager.getInstance().getString('drilldown', 'type_overlay'), value: VidiunAdType.OVERLAY}];
			
			private static const PROVIDERS:Array = [{label: ResourceManager.getInstance().getString('drilldown', 'provider_vast'), value: 'vast'},
				{label: ResourceManager.getInstance().getString('drilldown', 'provider_other'), value: 'other'}];
			
			private const LABEL_WIDTH:int = 80;
			
			public static const XML_EXL:String = "*.xml";
			
			/**
			 * clipper ruler is kept between different
			 * instances of the window as optimisation
			 * */
			private var _vClip:DisplayObject;
			private static var vClipLoader:SWFLoader;
			
			/**
			 * a flag used to determine we can talk with the vClip
			 * */
			private var _vClipReady:Boolean = false;
			
			/**
			 * player is kept between different
			 * instances of the window as optimisation
			 * */
			private var _vdp:DisplayObject;
			private static var vdpLoader:SWFLoader;
			
			
			/**
			 * to stop loop between updating playhead in vclip/vdp
			 * */
			private var _vdpInitiatedUpdate:Boolean = false;
			
			/**
			 * so that we won't add listeners to vclip and VDP every time
			 * initData is called (when paging between entries)
			 * */
			private var _listenersAddedVDP:Boolean = false;
			private var _listenersAddedVClip:Boolean = false;
			
			[Bindable]
			/**
			 * should components in the tab be editable
			 * */
			public var editable:Boolean = true;
			
			/**
			 * disable alerts in VDP
			 * */
			public var disableVDPAlerts:Boolean = true;
			
			public var context:ContextDataPack;
			
			
			/**
			 * data for this panel
			 * */
			public var model:CuePointsDataPack;
			
			[Bindable]
			/**
			 * number of currently present cuepoints on vClip
			 * */
			private var _counter:int = 0;
			
			/**
			 * change watcher to update vclip when entry duration changes
			 * */
			private var _durationWatcher:ChangeWatcher;
			
			[Bindable]
			/**
			 * @copy #selectedEntry
			 * */
			private var _selectedEntry:VidiunBaseEntry;
			
			private var _dpModel:IDataPackRepository;
			/**
			 * the entry being edited
			 * */
			public function get selectedEntry():VidiunBaseEntry {
				return _selectedEntry;
			}
			public function set selectedEntry(value:VidiunBaseEntry):void {
				if (_durationWatcher) {
					// unbind
					_durationWatcher.unwatch();
				}
				_selectedEntry = value;
				if (_vClip != null && _selectedEntry != null){
					_durationWatcher = BindingUtils.bindSetter(myFunc, _selectedEntry, "duration");
				}
			}
			
			public function get dataPackModel():IDataPackRepository{
				return _dpModel;
			}
			public function set dataPackModel(value:IDataPackRepository):void{
				_dpModel = value;
				context = _dpModel.getDataPack(ContextDataPack) as ContextDataPack;
				model = _dpModel.getDataPack(CuePointsDataPack) as CuePointsDataPack;
			}
			
			public function get helpAnchor():String{
				return "entry_ads";
			}
			
			[Bindable]
			/**
			 * is the cuepoints details form enabled
			 * */
			private var _formEnabled:Boolean = false;
			
			[Bindable]
			/**
			 * the cuepoint currently being edited
			 * */
			private var _selectedCuePoint:VidiunAdCuePoint;
			
			/**
			 * change watcher for reacting to cueopints count being set on model
			 * */
			private var _watchCPCount:ChangeWatcher;
			/**
			 * change watcher for reacting to reloadCuePoints being set on model
			 * */
			private var _watchCPReload:ChangeWatcher;
			
			/**
			 * image for VDP when entry is in no_content status
			 * */
			private var _img:Image;
			
			/**
			 * file reference object used for bulk upload
			 * */
			private var _bulkUpldFileRef:FileReference;
			
			/**
			 * current playhead position, in ms.
			 * */
			private var _playheadPosition:Number;
			
			private var _doValidation:Boolean = false;
			private var _inTransition:Boolean;
			
			/**
			 * set by RnP, allow setting vast cuepoints without ad tag url
			 * */
			public var allowVastWithoutAdTag:Boolean = true;
			
			
			/**
			 * validate all the cuepoints on vClip
			 * */
			public function validate():void {
				var success:Boolean = true;	// validation result
				var errorMessage:String;
				var errorTitle:String;
				
				_selectedCuePoint = null;
				_formEnabled = false;
				if (_vClipReady) {
					var cpresult:Boolean;
					var cps:Array = getCuepoints();
					for each (var cp:VidiunAdCuePoint in cps) {
						cpresult = validateCuePoint(cp);
						// mark this cp as in/valid
						_vClip["setError"](!cpresult, cp.id);
						success &&= cpresult;
						
					}
					if (!success) {
						errorMessage = resourceManager.getString('drilldown', 'ads_error_string'); 
						errorTitle = resourceManager.getString('drilldown', 'ads_error_title'); 
					}
					_doValidation = true;
				}
				// otherwise, the component wasn't ready so no data 
				// could have changed to invalid data
				
				var e:ValidationResultEvent = new ValidationResultEvent(ValidationResultEvent.VALIDATION_COMPLETE, success, errorMessage, errorTitle);
				dispatchEvent(e);
			}
			
			
			public function clear():void {
			}
			
			
			public function init():void {
				Security.allowDomain("*");
				PermissionManager.getInstance().applyAllAttributes(this, PanelConsts.ADS_PANEL);
				
				if (!_watchCPCount) {
					_watchCPCount = BindingUtils.bindSetter(adjustBulkActions, model, "cuepointsCount");
				}
				if (!_watchCPReload) {
					_watchCPReload = BindingUtils.bindSetter(callReloadCuePoints, model, "reloadCuePoints");
				}
			}
			
			/**
			 * reset vclip to accept new duration
			 * */
			private function myFunc(newDuration:Number):void {
				if (_selectedEntry.status == VidiunEntryStatus.READY) {
					if (_vClip) {
						_vClip["setEntryId"](_selectedEntry.id);
					}
					if (_vdp) {
						_vdp["sendNotification"](VdpEventTypes.CHANGE_MEDIA, {entryId: _selectedEntry.id});
					}
				}
			}
			
			/**
			 * trace the error instead of crashing the browser
			 * */
			private function uncaughtErrorHandler(event:Event):void {
				event.preventDefault();
				trace("uncaughtErrorHandler (EntryAds): ", event, event["error"]);
			}
			
			
			
			/**
			 * stop VDP if it happens to be playing
			 * */
			private function hideHandler(event:FlexEvent):void {
				if (_vdp){
					_vdp["sendNotification"](VdpEventTypes.DO_PAUSE);
				}
			}
			
			
			public function destroy():void {
				if (_vdp) {
					_vdp.removeEventListener(VdpEventTypes.PLAYER_PLAYED, handleVdpEvents, false);
					_vdp.removeEventListener(VdpEventTypes.PLAYER_PAUSED, handleVdpEvents, false);
					_vdp.removeEventListener(VdpEventTypes.PLAYER_PLAY_END, handleVdpEvents, false);
					_vdp.removeEventListener(VdpEventTypes.DO_SEEK, handleVdpEvents, false);
					_vdp["sendNotification"](VdpEventTypes.DO_PAUSE);
				}
				if (_vClip) {
					removeVClipListeners();
				}
				if (_watchCPCount) {
					_watchCPCount.unwatch();
				}
				if (_watchCPReload) {
					_watchCPReload.unwatch();
				}
				if (_durationWatcher) {
					_durationWatcher.unwatch();
				}
			}
			
			
			public function initData():void {
				_doValidation = false;
				_selectedCuePoint = null;
				_formEnabled = false;
				// reset number of cuepoints
				var cg:CuePointEvent = new CuePointEvent(CuePointEvent.RESET_CUEPOINTS_COUNT);
				controller.dispatch(cg);
				loadWidgets();
				// get number of entry cuepoints
				cg = new CuePointEvent(CuePointEvent.COUNT_CUEPOINTS);
				cg.data = _selectedEntry.id;
				controller.dispatch(cg);
			}
			
			
			
			/**
			 * reload cue points if true
			 * @internal
			 * used after bulk uploads - the command changes this value on the model.
			 * */
			private function callReloadCuePoints(value:Boolean):void {
				if (value && _vClip) {
					// reload cue points
					_vClip["loadCuePoints"]();
				}
			}
			
			
			
			private function updateVClipStatus(setEntryId:Boolean = true):void {
				var sm:VidiunMediaEntry = _selectedEntry as VidiunMediaEntry;
				if (sm.status != VidiunEntryStatus.READY || (sm.mediaType != VidiunMediaType.AUDIO && sm.mediaType != VidiunMediaType.VIDEO)) {
					if (_vClip["isReady"]()) {
						_vClip["setDisabled"](true);
					}
				}
				else {
					if (setEntryId && _vClip["isReady"]()) {
						_vClipReady = false;
						_vClip["setEntryId"](_selectedEntry.id);
					}
				}
				
				if (_durationWatcher == null && sm != null){
					_durationWatcher = BindingUtils.bindSetter(myFunc, _selectedEntry, "duration");
				}
			}
			
			
			private function updateVdpStatus(setEntryId:Boolean = true):void {
				if (_selectedEntry.status != VidiunEntryStatus.READY) {
					// entry not ready, show image and hide VDP
					if (!_img) {
						_img = new Image();
					}
					_img.source = StyleManager.getStyleDeclaration(".imageBank").getStyle("noContentImg");
					if (!_img.parent) {
						vdpHolder.addChild(_img);
					}
					if (_vdp && vdpLoader.parent) {
						vdpHolder.removeChild(vdpLoader);
					}
				}
				else {
					// add vdp, remove image, set entry id
					if (_vdp) {
						if (!vdpLoader.parent) {
							vdpHolder.addChild(vdpLoader);
						}
						if (setEntryId) {
							_vdp["sendNotification"](VdpEventTypes.CHANGE_MEDIA, {entryId: _selectedEntry.id});
						}
					}
					if (_img && _img.parent) {
						vdpHolder.removeChild(_img);
					}
				}
			}
			
			
			
			
			public function save():void {
				if (isChanged()) {
//					_vClip.addEventListener(VClipEventTypes.SAVED, handleVClipEvents);
					_vClip["save"]();
				}
				else {
					dispatchEvent(new InternalVedEvent(InternalVedEvent.PANEL_DATA_SAVED));
				}
			}
			
			
			/**
			 * has the data in the panel changed since last save?
			 * */
			public function isChanged():Boolean {
				if (_vClipReady) {
					return _vClip["isSaveRequired"]();
				}
				return false;
			}
			
			
			
			/**
			 * set the given CP's values in the details form.
			 * */
			private function showCuePointDetails(o:Object):void {
				var cp:VidiunAdCuePoint = new VidiunAdCuePoint();
				ObjectUtil.copyObject(o, cp);
				_selectedCuePoint = cp;
				// if roles and permissions allow editing, make the form editable
				if (editable) {
					_formEnabled = true;
				}
				cbType.selectedIndex = getAdType(_selectedCuePoint);
				cbProvider.selectedItem = getAdProvider(_selectedCuePoint);
				if (_doValidation) {
					validateCuePoint(_selectedCuePoint, true);
				}
			}
			
			
			/**
			 * was the given cuepoint already saved to DB
			 * @param cp 	cuepoint to check
			 * */
			private function isNewCuepoint(cp:VidiunAdCuePoint):Boolean {
				return cp.createdAt == int.MIN_VALUE;
			}
			
			
			/**
			 * load VDP and VClip or add them to stage, as needed.
			 * */
			private function loadWidgets():void {
				if (EntryAds.vClipLoader) {
					vClipHolder.addChild(vClipLoader);
					_vClip = vClipLoader.content["application"] as DisplayObject;
					_vClip.width = vClipHolder.width;
					addVClipListeners();
					if (selectedEntry) {
						updateVClipStatus(true);
					}
				}
				else {
					var url:String = context.protocol + context.cdnHost + "/vgeneric/ui_conf_id/" + context.vClipAdsUiconf;
					EntryAds.vClipLoader = new SWFLoader();
					vClipLoader.trustContent = true;
					vClipHolder.addChild(vClipLoader);
					vClipLoader.addEventListener(Event.COMPLETE, onVClipLoaded);
					vClipLoader.scaleContent = true;
					vClipLoader.percentWidth = 100;
					vClipLoader.percentHeight = 100;
					vClipLoader.loaderContext = new LoaderContext(false, new ApplicationDomain(), SecurityDomain.currentDomain);
					vClipLoader.load(url);
				}
				
				if (EntryAds.vdpLoader) {
					vdpHolder.addChild(vdpLoader);
					_vdp = vdpLoader.content;
					if (!_listenersAddedVDP) {
						
						addVDPListeners();
						_listenersAddedVDP = true;
					}
					if (selectedEntry) {
						updateVdpStatus(true);
					}
				}
				else {
					if (_selectedEntry && _selectedEntry.status == VidiunEntryStatus.READY) {
						var newUrl:String = context.protocol + context.cdnHost + "/vwidget/wid/_" + context.vc.partnerId + "/ui_conf_id/" + context.drilldownAdsUiconf + "/nowrapper/1";
						EntryAds.vdpLoader = new SWFLoader();
						vdpLoader.addEventListener(Event.COMPLETE, onVdpLoaded);
						vdpLoader.scaleContent = false;
						vdpLoader.loaderContext = new LoaderContext(true, new ApplicationDomain(), SecurityDomain.currentDomain);
						vdpLoader.load(newUrl);
					}
					else {
						updateVdpStatus(false);
					}
				}
			}
			
			private function addVDPListeners():void {
				_vdp.addEventListener(VdpEventTypes.PLAYER_PLAYED, handleVdpEvents, false, 0, true);
				_vdp.addEventListener(VdpEventTypes.PLAYER_PAUSED, handleVdpEvents, false, 0, true);
				_vdp.addEventListener(VdpEventTypes.PLAYER_PLAY_END, handleVdpEvents, false, 0, true);
				_vdp.addEventListener(VdpEventTypes.DO_SEEK, handleVdpEvents, false, 0, true);
			}
			
			/**
			 * wait for vClip application to be ready
			 * */
			private function onVClipLoaded(e:Event):void {
				vClipLoader.removeEventListener(Event.COMPLETE, onVClipLoaded);
				vClipLoader.width = vClipHolder.width;
				vClipLoader.height = vClipHolder.height;
				vClipLoader.content.addEventListener(FlexEvent.APPLICATION_COMPLETE, onVClipApplicationReady);
			}
			
			
			private function onVClipApplicationReady(e:Event):void {
				// e.target is the systemManager for VClip
				e.target.removeEventListener(FlexEvent.APPLICATION_COMPLETE, onVClipApplicationReady);
				_vClip = e.target.application as DisplayObject;
				initVClip();
			}
			
			
			/**
			 * initialize vClip
			 * */
			private function initVClip():void {
				var params:Object = {};
				params.vs = context.vc.vs;
				params.host = context.rootUrl;
				params.protocol = context.protocol;
				params.cdnHost = context.cdnHost;
				params.state = "cuePointsState";
				params.showControlBar = "true";
				params.partner_id = context.vc.partnerId;
				params.uiconf_id = context.vClipAdsUiconf;
				params.cuepointType = VidiunCuePointType.AD;
				addVClipListeners();
				_vClip["init"](params);
				_vClip.width = vClipHolder.width;
			}
			
			
			private function addVClipListeners():void {
				if (!_listenersAddedVClip) {
					_vClip.addEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.SELECTED_ASSET_REMOVED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.ALL_ASSETS_REMOVED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.CUE_POINT_CHANGED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.SELECTED_ASSET_CHANGED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.ENTRY_READY, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.CLIPPER_ERROR, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.CUE_POINT_ADDED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.CLIPPER_READY, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.PLAYHEAD_DRAG_DROP, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.PLAYHEAD_DRAG_START, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.ZOOM_CHANGED, handleVClipEvents);
					_vClip.addEventListener(VClipEventTypes.SAVED, handleVClipEvents);
					_listenersAddedVClip = true;
				}
			}
			
			
			private function removeVClipListeners():void {
				_vClip.removeEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.SELECTED_ASSET_REMOVED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.ALL_ASSETS_REMOVED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.CUE_POINT_CHANGED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.SELECTED_ASSET_CHANGED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.ENTRY_READY, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.CLIPPER_ERROR, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.CUE_POINT_ADDED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.CLIPPER_READY, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.PLAYHEAD_DRAG_DROP, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.PLAYHEAD_DRAG_START, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.ZOOM_CHANGED, handleVClipEvents);
				_vClip.removeEventListener(VClipEventTypes.SAVED, handleVClipEvents);
			}
			
			
			/**
			 * handle all vClip events
			 * */
			private function handleVClipEvents(e:Event):void {
				e.stopImmediatePropagation();
				switch (e.type) {
					case VClipEventTypes.PLAYHEAD_DRAG_START:
						_vClip.removeEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents);
						break;
					case VClipEventTypes.PLAYHEAD_DRAG_DROP:
						_playheadPosition = parseFloat(e["data"]);
						_vClip.addEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents);
						updateVdpPlayhead(_playheadPosition / 1000);
						break;
					
					case VClipEventTypes.CLIPPER_READY:
						updateVClipStatus(true);
						break;
					case VClipEventTypes.ENTRY_READY:
						// we get this after vclip finished loading entry data
						_vClipReady = true;
						_vClip["setDisabled"](!editable);
						break;
					case VClipEventTypes.PLAYHEAD_UPDATED:
						var value:Number = parseFloat(e["data"]);
						if (value != _playheadPosition) {
							updateVdpPlayhead(value / 1000);
							_playheadPosition = value;
						}
						break;
					case VClipEventTypes.SELECTED_ASSET_REMOVED:
						_formEnabled = false;
						_selectedCuePoint = null;
						_counter--;
						if (_counter < 0) {
							_counter = 0;
							trace("removing more cuepoints than we have..");
						}
						break;
					case VClipEventTypes.ALL_ASSETS_REMOVED:
						_formEnabled = false;
						_counter = 0;
						break;
					case VClipEventTypes.SELECTED_ASSET_CHANGED:
						_inTransition = true;
						focusManager.setFocus(tiName);
						showCuePointDetails(e["data"]);
						_inTransition = false;
						break;
					case VClipEventTypes.CUE_POINT_CHANGED:
						if (e["data"].id == _selectedCuePoint.id) {
							showCuePointDetails(e["data"]);
						}
						else {
							trace("ignoring update for",e["data"].id); 
						}
						break;
					case VClipEventTypes.CLIPPER_ERROR:
						onVClipError(e["data"]);
						break;
					case VClipEventTypes.CUE_POINT_ADDED:
						_counter++;
						break;
					case VClipEventTypes.SAVED:
						dispatchEvent(new InternalVedEvent(InternalVedEvent.PANEL_DATA_SAVED));
						break;
					case VClipEventTypes.ZOOM_CHANGED:
						// pause VDP
						if (_vdp) {
							_vdp["sendNotification"](VdpEventTypes.DO_PAUSE);
						}
						break;
				}
			}
			
			
			/**
			 * show user the error.
			 * @internal
			 * error localization should be done in vClip, not VMC.
			 * */
			private function onVClipError(errorVo:Object):void {
				// errorVo.messageText, errorVo.messageCode
				//TODO VClipErrorCodes.CUEPOINT_LOCATION_FAILED - don't show error right away, wait for 
				// the panel to show and only then show.
				if (errorVo.messageCode != VClipErrorCodes.CUEPOINT_LOCATION_FAILED) {
					Alert.show(errorVo.messageText);
				}
			}
			
			
			
			private function onVdpLoaded(e:Event):void {
				var loader:SWFLoader = e.target as SWFLoader;
				loader.width = vdpHolder.width;
				loader.height = vdpHolder.height;
				_vdp = loader.content;
				updateVdpStatus(false);
				if (!vdpLoader.parent) {
					vdpHolder.addChild(vdpLoader);
				}
				if (_img && _img.parent) {
					vdpHolder.removeChild(_img);
				}
				if (vdpLoader.loaderInfo.hasOwnProperty("uncaughtErrorEvents"))
					IEventDispatcher(vdpLoader.loaderInfo["uncaughtErrorEvents"]).addEventListener("uncaughtError", uncaughtErrorHandler, false, 1, true);
				initVdp();
			}
			
			
			/**
			 * initialize VDP
			 */
			private function initVdp():void {
				//set vdp params
				var params:Object = new Object();
				params.entryId = _selectedEntry.id;
				params.vs = context.vc.vs;
				params.partnerId = context.vc.partnerId;
				params.subpId = context.vc.partnerId + "00";
				params.cdnHost = context.cdnHost;
				
				params.allowCookies = true;
				params.debugMode = context.debugMode; 
				params.disableAlerts = disableVDPAlerts;
				
				_vdp["flashvars"] = params;
				//start the loading sequence of the vdp	
				_vdp["init"]();
				addVDPListeners();
			}
			
			
			private function handleVdpEvents(e:Event):void {
				switch (e.type) {
					case VdpEventTypes.PLAYER_PLAYED:
						if (_vClip) {
							_vClip.removeEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents, false);
						}
						_vdp.addEventListener(VdpEventTypes.PLAYER_UPDATE_PLAYHEAD, handleVdpEvents, false, 0, true);
						break;
					case VdpEventTypes.PLAYER_PAUSED:
					case VdpEventTypes.PLAYER_PLAY_END:
						if (_vClip) {
							_vClip["scrollToPoint"](_playheadPosition, true);
							_vdp.removeEventListener(VdpEventTypes.PLAYER_UPDATE_PLAYHEAD, handleVdpEvents, false);
							_vClip.addEventListener(VClipEventTypes.PLAYHEAD_UPDATED, handleVClipEvents, false, 0, true);
						}
						break;
					case VdpEventTypes.DO_SEEK:
						if (_vClipReady) {
							if (_vdpInitiatedUpdate)  {
								if (!isNaN(parseFloat(e["data"]))) {
									// when seeking in VDP we want vClip to load images.
									_vClip["scrollToPoint"](parseFloat(e["data"]) * 1000, true);
								}
							}
							else {
								_vdpInitiatedUpdate = true;
							}
						}
						break;
					case VdpEventTypes.PLAYER_UPDATE_PLAYHEAD:
						if (_vClipReady) {
							if (!isNaN(parseFloat(e["data"]))) {
								// we only listen to playhead update while in "play" mode, 
								// and in this case we don't want vClip to load images.
								_playheadPosition = parseFloat(e["data"]) * 1000;
								_vClip["scrollToPoint"](_playheadPosition, false);
							}
						}
						break;
				}
			}
			
			
			/**
			 * update vdp with new time
			 * @param n new time in seconds
			 * */
			private function updateVdpPlayhead(n:Number):void {
				_vdpInitiatedUpdate = false;
//				if (_vdp) {
//					if (_vdpFirstPlayed) {
//						// vdp played before. just seek
						_vdp["sendNotification"](VdpEventTypes.DO_SEEK, n);
//					}
//					else {
//						// cause first play
//						_vClipInitiatedPlay = true;
//						_vdp["setAttribute"]("mediaProxy", "mediaPlayFrom", n);
//						_vdp["sendNotification"](VdpEventTypes.DO_PLAY);
//					}
//				}
			}
			
			
			private function updateCuePointData(e:Event):void {
				if (_inTransition) {
					trace("dropping update for ", _selectedCuePoint.id);
					return;
				}
				// timing
				_selectedCuePoint.startTime = teTiming.getTimeAsSeconds() * 1000;
				// name
				_selectedCuePoint.title = tiName.text;
				// provider
				var value:String = cbProvider.selectedItem.value;
				if (value == "vast") {
					_selectedCuePoint.protocolType = VidiunAdProtocolType.VAST;
					_selectedCuePoint.tags = '';
				}
				else {
					// "other" provider
					_selectedCuePoint.protocolType = VidiunAdProtocolType.CUSTOM;
					_selectedCuePoint.tags = tiProvider.text;
				}
				// source url
				_selectedCuePoint.sourceUrl = tiUrl.text;
				// ad type
				_selectedCuePoint.adType = (cbType.selectedItem) ? cbType.selectedItem.value : null;
				// duration
				if (_selectedCuePoint.adType == VidiunAdType.VIDEO) {
					_selectedCuePoint.endTime = _selectedCuePoint.startTime;
				}
				else {
					_selectedCuePoint.endTime = _selectedCuePoint.startTime + teDuration.getTimeAsSeconds() * 1000;
				}
				// update
				_vClip["updateCuePoint"](_selectedCuePoint);
			}
			
			
			
			
			
			/**
			 * validate required fields of the given cuepoint
			 * @param cp	cuepoint to test
			 * @return true if validation passed, false otherwise.
			 * */
			private function validateCuePoint(cp:VidiunAdCuePoint, showUI:Boolean = false):Boolean {
				var result:Boolean = true;
				// ad type - must have value
				if (cp.adType != VidiunAdType.VIDEO && cp.adType != VidiunAdType.OVERLAY) {
					if (showUI) {
						cbType.errorString = resourceManager.getString('drilldown', 'ads_err_no_type');
					}
					result = false;
				}
				else if (showUI) {
					cbType.errorString = "";
				}
				// duration
				if (cp.adType == VidiunAdType.OVERLAY) {
					if (cp.endTime < cp.startTime) {
						if (showUI) {
							teDuration.errorString = resourceManager.getString('drilldown', 'ads_err_end_before_start');
						}
						result &&= false;
					}
					else if (cp.endTime > (_selectedEntry as VidiunMediaEntry).duration * 1000) {
						if (showUI) {
							teDuration.errorString = resourceManager.getString('drilldown', 'ads_err_end_after_duration');
						}
						result &&= false;
					}
					else if (showUI) {
						teDuration.errorString = "";
					}
				}
				else if (showUI) {
					teDuration.errorString = "";
				}
				// for vast - url may be mandatory
				if (cp.protocolType == VidiunAdProtocolType.VAST && !cp.sourceUrl && !this.allowVastWithoutAdTag) {
					if (showUI) {
						tiUrl.errorString = resourceManager.getString('drilldown', 'ads_err_vast_no_source');
					}
					result &&= false;
				}
				else if (showUI) {
					tiUrl.errorString = "";
				}
				return result;
			}
			
			
			/**
			 * retreive a list of cuepoints from vClip.
			 * @return all cuepoints currently displayed on vClip.
			 *
			 * @internal
			 * we have to translate vclip cps to vmc cps, because
			 * of the different ApplicationDomains.
			 * */
			private function getCuepoints():Array {
				var vclipcps:Array = _vClip["getAll"]();
				var cps:Array = new Array();
				var cp:VidiunAdCuePoint;
				for each (var o:Object in vclipcps) {
					cp = new VidiunAdCuePoint();
					ObjectUtil.copyObject(o, cp);
					cps.push(cp);
				}
				return cps;
			}
			
			
			
			/**
			 * calculate cuepoint duration
			 * */
			private function getDuration(acp:VidiunAdCuePoint):Object {
				if (acp.adType == VidiunAdType.VIDEO) {
					return teDuration.getTimeAsObject(0);
				}
				else if (acp.endTime != int.MIN_VALUE && acp.endTime != acp.startTime) {
					return teDuration.getTimeAsObject((acp.endTime - acp.startTime) / 1000);
				}
				else {
					return teDuration.getTimeAsObject(4);
				}
			}
			
			
			/**
			 * return the correct string to show in the ad provider text field,
			 * i.e. nothing for vast, or the tags string for "other".
			 * */
			private function getAdProviderText(acp:VidiunAdCuePoint):String {
				if (!acp || acp.protocolType == VidiunAdProtocolType.VAST) {
					return '';
				}
				else if (acp.protocolType == VidiunAdProtocolType.CUSTOM) {
					if (acp.tags) {
						return acp.tags;
					}
					else {
						return resourceManager.getString('drilldown', 'ads_default_provider');
					}
				}
				return resourceManager.getString('drilldown', 'ads_default_provider');
			}
			
			
			/**
			 * get the object in PROVIDERS that represents the tags of the given CP
			 * @param cp
			 * */
			private function getAdProvider(cp:VidiunAdCuePoint):Object {
				var value:String;
				if (cp.protocolType == VidiunAdProtocolType.VAST) {
					value = "vast"
				}
				else if (cp.protocolType == VidiunAdProtocolType.CUSTOM) {
					value = "other";
				}
				
				for (var i:int = 0; i < PROVIDERS.length; i++) {
					if (PROVIDERS[i].value == value) {
						return PROVIDERS[i];
					}
				}
				// the last object is the "Other"
				return PROVIDERS[PROVIDERS.length - 1];
			}
			
			
			/**
			 * get the object in AD_TYPES that represents the adType of the given CP
			 * @param cp
			 * */
			private function getAdType(cp:VidiunAdCuePoint):int {
				for (var i:int = 0; i < AD_TYPES.length; i++) {
					if (AD_TYPES[i].value == cp.adType) {
						return i;
					}
				}
				return -1;
			}
			
			
			
			private function removeAllCuePoints(event:MouseEvent):void {
				if (_vClipReady) {
					_vClip["removeAll"]();
				}
			}
			
			
			
			
			// =====================================================================
			// BULK RELATED STUFF
			// =====================================================================
			
			/**
			 * adjust the dataprovider for file actions dropdown
			 * @param cuepoints count
			 * */
			private function adjustBulkActions(value:Object):void {
				// copy the array for the new entry
				var ar:Array = BULK_ACTIONS.concat();
				var i:int;
				if (value != null && value == 0) {
					// remove the download option
					for (i = 0; i<ar.length; i++) {
						if (ar[i].value == "ads_bulk_download") {
							ar.splice(i, 1);
							break;
						}
					}
				}
				if (!editable) {
					// remove the upload action
					for (i = 0; i<ar.length; i++) {
						if (ar[i].value == "ads_bulk_upload") {
							ar.splice(i, 1);
							break;
						}
					}
				}
				cbActions.dropdown.dataProvider = ar;
				cbActions.dataProvider = ar;
				cbActions.selectedIndex = -1;
				cbActions.enabled = true;
			}
			
			
			private function handleBulkActions(event:ListEvent):void {
				var action:String = (event.target as ComboBox).selectedItem.value;
				switch (action) {
					case 'ads_bulk_upload':
						_bulkUpldFileRef = new FileReference();
						_bulkUpldFileRef.addEventListener(Event.SELECT, addBulkUpload);
						_bulkUpldFileRef.browse(new Array(new FileFilter(resourceManager.getString('drilldown', 'files') + ' (' + XML_EXL + ')', XML_EXL)));
						break;
					case 'ads_bulk_download':
						var cg:CuePointEvent = new CuePointEvent(CuePointEvent.DOWNLOAD_CUEPOINTS);
						cg.data = _selectedEntry.id;
						controller.dispatch(cg);
						break;
					case 'ads_bulk_sample':
						// download samples file
						_bulkUpldFileRef = new FileReference();
						var req:URLRequest = new URLRequest(model.cuepointsSamplesUrl);
						_bulkUpldFileRef.download(req);
						break;
				}
				cbActions.selectedIndex = -1;
			}
			
			
			/**
			 * on buld file selected
			 * */
			private function addBulkUpload(event:Event):void {
				_bulkUpldFileRef.removeEventListener(Event.SELECT, addBulkUpload);
				var cg:CuePointEvent = new CuePointEvent(CuePointEvent.UPLOAD_CUEPOINTS);
				cg.data = _bulkUpldFileRef;
				controller.dispatch(cg);
			}
			
			
			/**
			 * after changing the CB dataprovider, fix dropdown size
			 * (Flex 3.5 bug)
			 * */
			private function cbActions_updateCompleteHandler(event:FlexEvent):void {
				if (cbActions.dropdown) {
					cbActions.dropdown.width = cbActions.width;
				}
			}
			
			// =====================================================================
			
			/**
			 * stop VDP whenever the user interacts with vclip
			 * */
			protected function vClipHolder_mouseDownHandler(event:MouseEvent):void {
				if (_vdp && _vdp.hasEventListener(VdpEventTypes.PLAYER_UPDATE_PLAYHEAD)) {
					_vdp["sendNotification"](VdpEventTypes.DO_PAUSE);
				}
			}
		]]>
	</mx:Script>
	<control:AdsTabController id="controller" />
	<mx:HBox width="100%">
		<mx:VBox width="100%" height="{vdpHolder.height}">
			<mx:HBox width="100%">
				<mx:ComboBox id="cbActions" width="100%" change="handleBulkActions(event)"
							 updateComplete="cbActions_updateCompleteHandler(event)"
							 prompt="{resourceManager.getString('drilldown', 'ads_bulk_actions')}" enabled="false"/>
				<mx:Spacer width="100%"/>
			</mx:HBox>
			<mx:Spacer height="10"/>
			<mx:HRule width="100%"/>
			<mx:Spacer height="10"/>
			<mx:Text htmlText="{resourceManager.getString('drilldown', 'ads_explain')}" width="100%" styleName="adsExplain"
					 visible="{!_formEnabled}" includeInLayout="{!_formEnabled}"/>
			<mx:VBox id="details" width="100%" visible="{_formEnabled}" includeInLayout="{_formEnabled}">
				<mx:HBox styleName="noPadding">
					<mx:Label text="{resourceManager.getString('drilldown', 'timing')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<controls:TimeStepper id="teTiming" enabled="{_formEnabled}" styleName="timeEntry"
										  maximum="{(_selectedEntry as VidiunMediaEntry).duration}"
										  timeValue="{teTiming.getTimeAsObject(_selectedCuePoint.startTime/1000)}"
										  showHours="true" showSeconds="true" showMiliseconds="true" is24Hour="true"
										  change="updateCuePointData(event)"/>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('drilldown', 'ads_type')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:ComboBox id="cbType" width="100%" enabled="{_formEnabled}" dataProvider="{AD_TYPES}"
								 prompt="{resourceManager.getString('drilldown', 'ads_ad_type')}"
								 change="updateCuePointData(event)"/>
					<mx:Spacer/>
					<mx:Label text="{resourceManager.getString('drilldown', 'durationLabel')}" styleName="formLabel"
							  enabled="{teDuration.enabled}"/>
					<controls:TimeStepper id="teDuration" enabled="{_formEnabled &amp;&amp; cbType.selectedIndex == 1}"
										  showHours="true" showMiliseconds="true" showSeconds="true" is24Hour="true"
										  timeValue="{getDuration(_selectedCuePoint)}"
										  change="updateCuePointData(event)" styleName="timeEntry"/>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('drilldown', 'ads_provider')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:VBox width="100%" styleName="noPadding">
						<mx:ComboBox id="cbProvider" enabled="{_formEnabled &amp;&amp; isNewCuepoint(_selectedCuePoint)}" dataProvider="{PROVIDERS}"
									 change="updateCuePointData(event)"/>
						<text:DefaultLabelTextArea id="tiProvider" width="100%" height="{tiUrl.height}"
													   defaultLabel="{resourceManager.getString('drilldown', 'ads_default_provider')}"
													   enabled="{cbProvider.selectedItem.value == 'other'}"
													   defaultLabelStyleName="textAreaDefaultLabel"
													   change="updateCuePointData(event)"/>
					</mx:VBox>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('drilldown', 'ads_url')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:TextInput id="tiUrl" width="100%" text="{_selectedCuePoint.sourceUrl}"
								  change="updateCuePointData(event)" styleName="drilldownInput"/>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('drilldown', 'ads_name')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:TextInput id="tiName" width="100%" enabled="{_formEnabled}" text="{_selectedCuePoint.title}"
								  change="updateCuePointData(event)" styleName="drilldownInput"/>
				</mx:HBox>
			</mx:VBox>
		</mx:VBox>
		<mx:HBox id="vdpHolder" width="300" height="255" tabChildren="false" tabEnabled="false"/>
	</mx:HBox>
	<mx:HBox id="vClipHolder" width="754" height="120" mouseDown="vClipHolder_mouseDownHandler(event)"/>
	<mx:HBox width="100%">
		<mx:Spacer width="100%"/>
		<mx:LinkButton label="{resourceManager.getString('drilldown', 'ads_remove_all')}" click="removeAllCuePoints(event)"
					   visible="{_counter > 0 &amp;&amp; editable}"
					   includeInLayout="{_counter > 0  &amp;&amp; editable}"/>
	</mx:HBox>

</mx:Module>
